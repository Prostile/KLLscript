// definitions.h
#ifndef DEFINITIONS_H
#define DEFINITIONS_H

#include <string> // Используется косвенно другими заголовками, которые могут включать этот

// --- Типы Лексем (Токенов) ---
enum class TokenType {
    // Литералы и идентификаторы
    T_IDENTIFIER,   // Идентификатор
    T_NUMBER_INT,   // Целочисленная константа
    T_NUMBER_FLOAT, // Вещественная константа

    // Ключевые слова
    T_KW_INT,       // int
    T_KW_FLOAT,     // float
    T_KW_ARR,       // arr (для объявления массивов, тип элементов будет int или float)
    T_KW_IF,        // if
    T_KW_ELSE,      // else
    T_KW_WHILE,     // while
    T_KW_BEGIN,     // begin
    T_KW_END,       // end
    T_KW_CIN,       // cin
    T_KW_COUT,      // cout

    // Операторы и разделители (используем ASCII коды, где это удобно и однозначно)
    T_ASSIGN = '=', // = (Присваивание)
    T_PLUS = '+', // + (Сложение)
    T_MINUS = '-', // - (Вычитание)
    T_MULTIPLY = '*', // * (Умножение)
    T_DIVIDE = '/', // / (Деление)
    T_LPAREN = '(', // ( (Левая скобка)
    T_RPAREN = ')', // ) (Правая скобка)
    T_LBRACKET = '[', // [ (Левая квадратная скобка - индексация)
    T_RBRACKET = ']', // ] (Правая квадратная скобка - индексация)
    T_SEMICOLON = ';', // ; (Точка с запятой)
    T_COMMA = ',', // , (Запятая - для будущих расширений, если понадобятся, или для списков аргументов, но функций пока нет)

    // Операторы сравнения
    T_EQUAL = '~', // ~ (Равенство ==)
    T_GREATER = '>', // > (Больше)
    T_LESS = '<', // < (Меньше)
    T_NOT_EQUAL = '!', // ! (Неравенство !=)
    // Можно добавить >= (T_GREATER_EQUAL) и <= (T_LESS_EQUAL) если нужно,
    // сейчас они не указаны в задании, но часто бывают полезны.
    // Для простоты, пока оставляем только базовые 4.

    // Специальные токены
    T_EOF,          // Конец файла
    T_ERROR,        // Ошибка лексического анализа
    T_UNKNOWN       // Неизвестный или неинициализированный токен
};

// --- Типы операций ОПС (RPN - Reverse Polish Notation) ---
enum class RPNOpCode {
    // Операнды (значения будут храниться отдельно в RPNOperation)
    PUSH_VAR_ADDR,      // Положить адрес переменной в стек
    PUSH_ARRAY_ADDR,    // Положить адрес (базовый) массива в стек
    PUSH_CONST_INT,     // Положить целую константу в стек
    PUSH_CONST_FLOAT,   // Положить вещественную константу в стек

    // Арифметические операции (будут работать с типами на стеке)
    ADD,                // +
    SUB,                // -
    MUL,                // *
    DIV,                // /

    // Операции сравнения (результат - int: 0 для false, 1 для true)
    CMP_EQ,             // ~ (==)
    CMP_NE,             // ! (!=)
    CMP_GT,             // >
    CMP_LT,             // <

    // Операция присваивания
    ASSIGN,             // =

    // Операция индексации массива (результат - адрес элемента)
    INDEX,              // [ ]

    // Унарные операции ввода/вывода
    READ_INT,           // cin для int
    READ_FLOAT,         // cin для float
    WRITE_INT,          // cout для int
    WRITE_FLOAT,        // cout для float

    // Операции перехода
    JUMP,               // j (безусловный переход)
    JUMP_FALSE,         // jf (переход по лжи, значение на стеке должно быть 0)

    // Операции преобразования типов
    CONVERT_TO_FLOAT,   // Преобразовать верхний int на стеке в float
    CONVERT_TO_INT      // Преобразовать верхний float на стеке в int (усечение)

    // LABEL не нужен как отдельный OpCode, адрес перехода хранится в JUMP/JUMP_FALSE
};

// --- Типы символов в таблице символов ---
enum class SymbolType {
    VARIABLE_INT,
    VARIABLE_FLOAT,
    ARRAY_INT,      // Массив целых чисел
    ARRAY_FLOAT     // Массив вещественных чисел
    // UNKNOWN // Можно добавить для неинициализированных
};

#endif // DEFINITIONS_H